<!DOCTYPE html>
  <html lang="en">
  <head>
    <link rel="stylesheet" href="/style.css">
    
    <link rel="preload" href="/elm.js" as="script">
    <link rel="modulepreload" href="/index.js">
    
    <script defer="defer" src="/elm.js" type="text/javascript"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <script type="module">
import userInit from"/index.js";
let prefetchedPages=[window.location.pathname],initialLocationHash=document.location.hash.replace(/^#/,"");function loadContentAndInitializeApp(){let a=window.location.pathname.replace(/(w)$/,"$1/");a.endsWith("/")||(a+="/");const b=Elm.TemplateModulesBeta.init({flags:{secrets:null,baseUrl:document.baseURI,isPrerendering:!1,isDevServer:!1,isElmDebugMode:!1,contentJson:JSON.parse(document.getElementById("__ELM_PAGES_DATA__").innerHTML),userFlags:userInit.flags()}});return b.ports.toJsPort.subscribe(()=>{loadNamedAnchor()}),b}function loadNamedAnchor(){if(""!==initialLocationHash){const a=document.querySelector(`[name=${initialLocationHash}]`);a&&a.scrollIntoView()}}function prefetchIfNeeded(a){if(a.host===window.location.host&&!prefetchedPages.includes(a.pathname)){prefetchedPages.push(a.pathname),console.log("Preloading...",a.pathname);const b=document.createElement("link");b.setAttribute("as","fetch"),b.setAttribute("rel","prefetch"),b.setAttribute("href",origin+a.pathname+"/content.json"),document.head.appendChild(b)}}const appPromise=new Promise(function(a){document.addEventListener("DOMContentLoaded",()=>{a(loadContentAndInitializeApp())})});userInit.load(appPromise),"function"==typeof connect&&connect(function(a){appPromise.then(b=>{b.ports.fromJsPort.send({contentJson:a})})});const trigger_prefetch=b=>{const c=find_anchor(b.target);c&&c.href&&c.hasAttribute("elm-pages:prefetch")&&prefetchIfNeeded(c)};let mousemove_timeout;const handle_mousemove=a=>{clearTimeout(mousemove_timeout),mousemove_timeout=setTimeout(()=>{trigger_prefetch(a)},20)};addEventListener("touchstart",trigger_prefetch),addEventListener("mousemove",handle_mousemove);function find_anchor(a){for(;a&&"A"!==a.nodeName.toUpperCase();)a=a.parentNode;return a}
    </script>
    <title>BlogArticles in English</title>
    <meta name="generator" content="elm-pages v2.1.10">
    <link rel="manifest" href="/manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="canonical" href="https://elm-pages.com/fr" />    <meta name="description" content="TODO" />    <meta property="og:image" content="TODO" />    <meta property="og:image:secure_url" content="TODO" />    <meta property="og:image:alt" content="elm-pages logo" />    <meta property="og:title" content="TODO title" />    <meta property="og:url" content="https://elm-pages.com/fr" />    <meta property="og:description" content="TODO" />    <meta property="og:site_name" content="elm-pages" />    <meta property="twitter:card" content="summary" />    <meta property="twitter:title" content="TODO title" />    <meta property="twitter:description" content="TODO" />    <meta property="twitter:image" content="TODO" />    <meta property="twitter:image:alt" content="elm-pages logo" />    <meta property="og:type" content="website" />    <link rel="sitemap" type="application/xml" href="/sitemap.xml" />
    <script id="__ELM_PAGES_DATA__" type="application/json">{"staticData":{"308918358":"{\"parsedFrontmatter\":{\"title\":\"Le d\u00E9codage de JSON\"},\"withoutFrontmatter\":\"Comme indiqu\u00E9 dans la vid\u00E9o, une explication compl\u00E8te du d\u00E9codage JSON m\u00E9rite un article \u00E0 part enti\u00E8re. Il existe une br\u00E8ve introduction dans le guide officiel. Mais d'autres personnes ont d\u00E9j\u00E0 cr\u00E9\u00E9 des articles exhaustifs sur les cas plus complexes qui ne sont pas couverts par le guide. Par exemple, cet article sur elmprogramming.com.\\n\\nCompar\u00E9 \u00E0 d'autres langages comme JavaScript ou Ruby, il semble que le d\u00E9codage de JSON dans Elm soit inutilement compliqu\u00E9. Je me suis moi-m\u00EAme battu contre cela pendant un certain temps lorsque j'ai voulu \\\"juste lire du JSON\\\" en Elm pour la premi\u00E8re fois. Aujourd'hui, j'aimerais donc vous convaincre que ce n'est pas si compliqu\u00E9 que \u00E7a et que cette complexit\u00E9 suppl\u00E9mentaire en vaut la peine.\\n\\n\u00C0 la fin de la session de codage, nous nous sommes retrouv\u00E9s avec un d\u00E9codeur JSON qui ressemblait \u00E0 ceci :\\n\\nTraduit avec www.DeepL.com/Translator (version gratuite)\\n\"}","652872802":"{\"parsedFrontmatter\":{\"title\":\"Logging in English\"},\"withoutFrontmatter\":\"Why can't we just write `Debug.log \\\"a is:\\\" a` only? The reason is that the intention of the `let` block is to **give names** to expressions.\\n`Debug.log` is **the only** function in Elm that's not **pure** and where we don't care about its result.\\n**All other** we call **only** to get their result. So for our `Debug.log` line to have the same format as the other expressions in a `let` block, we'll just assign it the name `_` (the underscore).\\nBy doing so it can be avoided that the compiler has to implement an extra syntax rule **only** for the `Debug.log` call.\\n\\nThis is not the only use case for the underscore. We use it generally as an identifier for an expression that is not used further down the function body.\\n\\nI already did that in the [`mkEmptyRow` function](https://github.com/axelerator/elm-tetris/blob/episode5/src/Main.elm#L137):\\n\\n```Elm\\n  mkEmptyRow _ =\\n      Row <| map (\\\\_ -> Empty) (range 1 11)\\n``` \\n\\nI#m using the \\\"looping notion\\\" of the [`map` function](https://package.elm-lang.org/packages/elm/core/latest/List#map) to call another function on every element in a [range](https://package.elm-lang.org/packages/elm/core/latest/List#range) \\nBut in this function, I'm not really interested in the actual number for each iteration. By using the underscore as the identifier for the parameter we're giving a potential reader of the code an **early** sign that they don't have to care about it.\\n\"}","715542827":"[\"articles/2020-12-16#welcome/de.md\",\"articles/2020-12-16#welcome/en.md\",\"articles/2020-12-16#welcome/fr.md\"]","1182703688":"{\"jsonFile\":{\"published\":\"2019-12-17\"}}","1630532599":"{\"jsonFile\":{\"published\":\"2019-12-16\"}}","2218772462":"[\"articles/2020-12-16#welcome/meta.json\",\"articles/2020-12-17#goodbye/meta.json\"]","2563826063":"{\"parsedFrontmatter\":{\"title\":\"JSON Dekodierung\"},\"withoutFrontmatter\":\"Und schickt uns in den [offiziellen Guide](https://guide.elm-lang.org/effects/json.html) f\u00FCr mehr Details.\\nIch versuche eine alternative Erkl\u00E4rung zu geben die hoffentlich ein paar Fragen beantwortet die Entwickler haben die aus weniger 'funktionalen Umgebungen' kommen.\\n\\nEin `Decoder` ist also \\\"Ein Wert der wei\u00DF wie JSON Werte zu dekodieren sind\\\". Das erste was auff\u00E4llt ist, dass unser `keyDecoder` keinen Parameter animmt. Das ist im Sinne der Definition, denn wir berechnen nicht einen Wert aus gegebenen Parametern sondern geben einen konstanten Ausdruck zur\u00FCck.\\n\\nDas bringt die Frage auf: \\\"Wie kann ein **konstanter Wert** etwas dekodieren?\\\"\\nDas bringt uns zu den Grundprinzipien der funktionalen Programmierung zur\u00FCck: Funktionen **sind** Werte.\\nIn der Dokumentation sehen wir lediglich die 'linke Seite' der Typdefintion. \\nEs kann also durchaus sein, dass dieser Typ aus Varianten gebildet die eine Funktion enthalten.\\n\\nDie [Decoder-Bibliothek](https://package.elm-lang.org/packages/elm/json/latest/Json-Decode) enth\u00E4lt eine handvoll vordefinierter `Decoder` und Funktionen mit denen wir diese zu komplexeren Dekodierern zusammensetzen k\u00F6nnen.\\n\\nEin Typ dessen \\\"rechte\\\" Seite der Definition `type Decoder a = ???` wir nicht kennen wird auch ein **opaquer Typ** genannt.\\nDas hei\u00DFt der Entwickler dieses Typs m\u00F6chte nicht, dass wir die Implementierungsdetails kennen. Auf den ersten Blick mag das unn\u00F6tig einschr\u00E4nkend wirken.\\nRichtig eingesetzt sind opaque Typen aber extrem **befreiend**. Es bedeutet, dass ich als Anwedungsentwickler mich nicht unn\u00F6tig mit Implementierungsdetails auseinanderzusetzen brauch. Und da ich mit diesem Teil des Systems nicht interagieren kann, kann ich es auch nicht 'falsch bedienen' oder kaputt machen.\\n\\nAnhand unseres `keyDecoder` werden wir sehen wir ein solcher Typ, obwohl wir nichts \u00FCber seine Interna wissen, dennoch sehr n\u00FCtzlich sein kann.\\n\"}","3470183754":"[\"articles/2020-12-17#goodbye/de.md\",\"articles/2020-12-17#goodbye/en.md\"]","3787254055":"{\"parsedFrontmatter\":{\"title\":\"Logging auf Deutsch\"},\"withoutFrontmatter\":\"Warum k\u00F6nnen wir nicht einfach nur `Debug.log \\\"a is:\\\" a` schreiben? Der Grund daf\u00FCr ist, dass der `let` Block ausschlie\u00DFlich dazu dient lokale Ausdr\u00FCcke zu benennen.\\n`Debug.log` ist die **einzige** Funktion in Elm die nicht **pure** ist und f\u00FCr deren R\u00FCckggabewert wir uns nicht interessieren.\\n**Alle anderen** Funktionen rufen wir auf um an den berechneten Wert zu kommen (und ihm im `let` einen lokalen Namen zu geben).\\nDamit das Format wie wir `Debug.log` aufrufen dasselbe ist wie das der \\\"normalen\\\" Ausdr\u00FCcke im `let` Block weisen wir den Ausdruck den Namen `_`(Unterstrich) zu.\\nMit dieser Konvention wird vermieden, dass der Compiler eine extra Syntax-Regel ausschlie\u00DFlich f\u00FCr die `Debug.log` Anweisung haben muss.\\n\\nDer Unterstrich kommt nicht nur hier zum Einsatz, sondern wird generell als Bezeichner verwendet wenn wir uns f\u00FCr den Inhalt des Ausdrucks nicht interessieren.  \\n\\nZum Beispiel auch in unserer [mkEmptyRow](https://github.com/axelerator/elm-tetris/blob/episode5/src/Main.elm#L137) Funktion:\\n\\n```Elm\\n  mkEmptyRow _ =\\n      Row <| map (\\\\_ -> Empty) (range 1 11)\\n``` \\n\\nWir nutzen den \\\"Wiederholungscharakter\\\" der [`map` Funktion](https://package.elm-lang.org/packages/elm/core/latest/List#map) um eine Funktion f\u00FCr jedes Element in einer [range](https://package.elm-lang.org/packages/elm/core/latest/List#range) aufzurufen.\\nAllerdings interessieren wir uns nicht f\u00FCr die tats\u00E4chliche Zahl.\\nWir geben dem Leser fr\u00FChzeitig einen Hinweis darauf in dem wir anstatt einen Namen den Unterstrich als Parameternamen verwenden.\\n\\n\"}","4138910861":"{\"parsedFrontmatter\":{\"title\":\"JSON Decoding\"},\"withoutFrontmatter\":\"As already mentioned in the video a complete explanation of JSON decoding warrants its own article. There is a [short introduction in the official guide](https://guide.elm-lang.org/effects/json.html).\\nBut other people have already created exhaustive articles about the more complex cases that are not covered there. For example [this article on elmprogramming.com](https://elmprogramming.com/decoding-json-part-1.html#decoding-json).\\n![eine wand yeah](one.jpg \\\"zoomable_1::title\\\")\\nCompared to other languages like JavaScript or Ruby it seems like decoding JSON in Elm is unnecessarily complicated. I fought with it for quite a while myself when I *'just wanted to read some JSON'* in Elm for the first time.\\nSo today I'd like to convince you that it's not *that* complicated after all and that the additional complexity is well worth it.\\n\\nAt the end of the coding session we ended up with a JSON decoder that looked like this:\\n![eine wand](two.jpg \\\"zoomable_2::title\\\")\\n\\nCompared to other languages like JavaScript or Ruby it seems like decoding JSON in Elm is unnecessarily complicated. I fought with it for quite a while myself when I *'just wanted to read some JSON'* in Elm for the first time.\\nSo today I'd like to convince you that it's not *that* complicated after all and that the additional complexity is well worth it.\\n\\nAt the end of the coding session we ended up with a JSON decoder that looked like this:\\n![eine wand](three.jpg \\\"zoomable_3::title\\\")\\nWhat?\\n\\n\"}"},"is404":false,"path":"fr"}</script>
    </head>
    <body>
      <div data-url="" display="none"></div>
      <div class="everything"><div class="header"><h1>our green maple home</h1></div><div class="content"><div class="navigation"><ul><li class="active"><a elm-pages:prefetch="" href="/de">Home</a></li><li class="languageSwitcher">de<ul><li><a elm-pages:prefetch="" href="/">en</a></li><li><a elm-pages:prefetch="" href="/de">de</a></li></ul></li></ul></div><div class="articleIndex"><div class="articleTeaser"><div class="teaserImg" style="background-image:url(/images/articles/2020-12-16%23welcome/images/teaser.jpg);"></div><div class="excerpt"><div><p class="postedOn">Monday, 16th December 2019</p><h2><a elm-pages:prefetch="" href="/fr/welcome">Le décodage de JSON</a></h2>Comme indiqué dans la vidéo, une explication complète du décodage JSON mérite un article à part entière. Il existe une brève introduction dans le guide officiel. Mais d'autres personnes ont déjà créé des articles exhaustifs sur les cas plus complexes qui ne sont pas couverts par le guide. Par exemple, cet article sur elmprogramming.com.</div></div></div></div></div><div class="footer"><ul><li><a href="https://www.instagram.com/OurGreenMapleHome/"><img alt="OurGreenMapleHome on Instagram" src="/images/instagram.svg"></a></li></ul></div></div>
    </body>
  </html>
  