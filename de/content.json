{"is404":false,"staticData":{"308918358":"{\"parsedFrontmatter\":{\"title\":\"Le décodage de JSON\"},\"withoutFrontmatter\":\"Comme indiqué dans la vidéo, une explication complète du décodage JSON mérite un article à part entière. Il existe une brève introduction dans le guide officiel. Mais d'autres personnes ont déjà créé des articles exhaustifs sur les cas plus complexes qui ne sont pas couverts par le guide. Par exemple, cet article sur elmprogramming.com.\\n\\nComparé à d'autres langages comme JavaScript ou Ruby, il semble que le décodage de JSON dans Elm soit inutilement compliqué. Je me suis moi-même battu contre cela pendant un certain temps lorsque j'ai voulu \\\"juste lire du JSON\\\" en Elm pour la première fois. Aujourd'hui, j'aimerais donc vous convaincre que ce n'est pas si compliqué que ça et que cette complexité supplémentaire en vaut la peine.\\n\\nÀ la fin de la session de codage, nous nous sommes retrouvés avec un décodeur JSON qui ressemblait à ceci :\\n\\nTraduit avec www.DeepL.com/Translator (version gratuite)\\n\"}","652872802":"{\"parsedFrontmatter\":{\"title\":\"Logging in English\"},\"withoutFrontmatter\":\"Why can't we just write `Debug.log \\\"a is:\\\" a` only? The reason is that the intention of the `let` block is to **give names** to expressions.\\n`Debug.log` is **the only** function in Elm that's not **pure** and where we don't care about its result.\\n**All other** we call **only** to get their result. So for our `Debug.log` line to have the same format as the other expressions in a `let` block, we'll just assign it the name `_` (the underscore).\\nBy doing so it can be avoided that the compiler has to implement an extra syntax rule **only** for the `Debug.log` call.\\n\\nThis is not the only use case for the underscore. We use it generally as an identifier for an expression that is not used further down the function body.\\n\\nI already did that in the [`mkEmptyRow` function](https://github.com/axelerator/elm-tetris/blob/episode5/src/Main.elm#L137):\\n\\n```Elm\\n  mkEmptyRow _ =\\n      Row <| map (\\\\_ -> Empty) (range 1 11)\\n``` \\n\\nI#m using the \\\"looping notion\\\" of the [`map` function](https://package.elm-lang.org/packages/elm/core/latest/List#map) to call another function on every element in a [range](https://package.elm-lang.org/packages/elm/core/latest/List#range) \\nBut in this function, I'm not really interested in the actual number for each iteration. By using the underscore as the identifier for the parameter we're giving a potential reader of the code an **early** sign that they don't have to care about it.\\n\"}","715542827":"[\"articles/2020-12-16#welcome/de.md\",\"articles/2020-12-16#welcome/en.md\",\"articles/2020-12-16#welcome/fr.md\"]","1182703688":"{\"jsonFile\":{\"published\":\"2019-12-17\"}}","1630532599":"{\"jsonFile\":{\"published\":\"2019-12-16\"}}","2218772462":"[\"articles/2020-12-16#welcome/meta.json\",\"articles/2020-12-17#goodbye/meta.json\"]","2563826063":"{\"parsedFrontmatter\":{\"title\":\"JSON Dekodierung\"},\"withoutFrontmatter\":\"Und schickt uns in den [offiziellen Guide](https://guide.elm-lang.org/effects/json.html) für mehr Details.\\nIch versuche eine alternative Erklärung zu geben die hoffentlich ein paar Fragen beantwortet die Entwickler haben die aus weniger 'funktionalen Umgebungen' kommen.\\n\\nEin `Decoder` ist also \\\"Ein Wert der weiß wie JSON Werte zu dekodieren sind\\\". Das erste was auffällt ist, dass unser `keyDecoder` keinen Parameter animmt. Das ist im Sinne der Definition, denn wir berechnen nicht einen Wert aus gegebenen Parametern sondern geben einen konstanten Ausdruck zurück.\\n\\nDas bringt die Frage auf: \\\"Wie kann ein **konstanter Wert** etwas dekodieren?\\\"\\nDas bringt uns zu den Grundprinzipien der funktionalen Programmierung zurück: Funktionen **sind** Werte.\\nIn der Dokumentation sehen wir lediglich die 'linke Seite' der Typdefintion. \\nEs kann also durchaus sein, dass dieser Typ aus Varianten gebildet die eine Funktion enthalten.\\n\\nDie [Decoder-Bibliothek](https://package.elm-lang.org/packages/elm/json/latest/Json-Decode) enthält eine handvoll vordefinierter `Decoder` und Funktionen mit denen wir diese zu komplexeren Dekodierern zusammensetzen können.\\n\\nEin Typ dessen \\\"rechte\\\" Seite der Definition `type Decoder a = ???` wir nicht kennen wird auch ein **opaquer Typ** genannt.\\nDas heißt der Entwickler dieses Typs möchte nicht, dass wir die Implementierungsdetails kennen. Auf den ersten Blick mag das unnötig einschränkend wirken.\\nRichtig eingesetzt sind opaque Typen aber extrem **befreiend**. Es bedeutet, dass ich als Anwedungsentwickler mich nicht unnötig mit Implementierungsdetails auseinanderzusetzen brauch. Und da ich mit diesem Teil des Systems nicht interagieren kann, kann ich es auch nicht 'falsch bedienen' oder kaputt machen.\\n\\nAnhand unseres `keyDecoder` werden wir sehen wir ein solcher Typ, obwohl wir nichts über seine Interna wissen, dennoch sehr nützlich sein kann.\\n\"}","3470183754":"[\"articles/2020-12-17#goodbye/de.md\",\"articles/2020-12-17#goodbye/en.md\"]","3787254055":"{\"parsedFrontmatter\":{\"title\":\"Logging auf Deutsch\"},\"withoutFrontmatter\":\"Warum können wir nicht einfach nur `Debug.log \\\"a is:\\\" a` schreiben? Der Grund dafür ist, dass der `let` Block ausschließlich dazu dient lokale Ausdrücke zu benennen.\\n`Debug.log` ist die **einzige** Funktion in Elm die nicht **pure** ist und für deren Rückggabewert wir uns nicht interessieren.\\n**Alle anderen** Funktionen rufen wir auf um an den berechneten Wert zu kommen (und ihm im `let` einen lokalen Namen zu geben).\\nDamit das Format wie wir `Debug.log` aufrufen dasselbe ist wie das der \\\"normalen\\\" Ausdrücke im `let` Block weisen wir den Ausdruck den Namen `_`(Unterstrich) zu.\\nMit dieser Konvention wird vermieden, dass der Compiler eine extra Syntax-Regel ausschließlich für die `Debug.log` Anweisung haben muss.\\n\\nDer Unterstrich kommt nicht nur hier zum Einsatz, sondern wird generell als Bezeichner verwendet wenn wir uns für den Inhalt des Ausdrucks nicht interessieren.  \\n\\nZum Beispiel auch in unserer [mkEmptyRow](https://github.com/axelerator/elm-tetris/blob/episode5/src/Main.elm#L137) Funktion:\\n\\n```Elm\\n  mkEmptyRow _ =\\n      Row <| map (\\\\_ -> Empty) (range 1 11)\\n``` \\n\\nWir nutzen den \\\"Wiederholungscharakter\\\" der [`map` Funktion](https://package.elm-lang.org/packages/elm/core/latest/List#map) um eine Funktion für jedes Element in einer [range](https://package.elm-lang.org/packages/elm/core/latest/List#range) aufzurufen.\\nAllerdings interessieren wir uns nicht für die tatsächliche Zahl.\\nWir geben dem Leser frühzeitig einen Hinweis darauf in dem wir anstatt einen Namen den Unterstrich als Parameternamen verwenden.\\n\\n\"}","4138910861":"{\"parsedFrontmatter\":{\"title\":\"JSON Decoding\"},\"withoutFrontmatter\":\"As already mentioned in the video a complete explanation of JSON decoding warrants its own article. There is a [short introduction in the official guide](https://guide.elm-lang.org/effects/json.html).\\nBut other people have already created exhaustive articles about the more complex cases that are not covered there. For example [this article on elmprogramming.com](https://elmprogramming.com/decoding-json-part-1.html#decoding-json).\\n![eine wand yeah](one.jpg \\\"zoomable_1::title\\\")\\nCompared to other languages like JavaScript or Ruby it seems like decoding JSON in Elm is unnecessarily complicated. I fought with it for quite a while myself when I *'just wanted to read some JSON'* in Elm for the first time.\\nSo today I'd like to convince you that it's not *that* complicated after all and that the additional complexity is well worth it.\\n\\nAt the end of the coding session we ended up with a JSON decoder that looked like this:\\n![eine wand](two.jpg \\\"zoomable_2::title\\\")\\n\\nCompared to other languages like JavaScript or Ruby it seems like decoding JSON in Elm is unnecessarily complicated. I fought with it for quite a while myself when I *'just wanted to read some JSON'* in Elm for the first time.\\nSo today I'd like to convince you that it's not *that* complicated after all and that the additional complexity is well worth it.\\n\\nAt the end of the coding session we ended up with a JSON decoder that looked like this:\\n![eine wand](three.jpg \\\"zoomable_3::title\\\")\\nWhat?\\n\\n\"}"},"path":"de"}